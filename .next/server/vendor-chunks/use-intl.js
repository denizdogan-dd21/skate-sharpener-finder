"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\n\n\n\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nvar IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}(IntlErrorCode || {});\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n    const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n    const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n    const dateTimeFormats = {\n        ...globalFormats?.dateTime,\n        ...inlineFormats?.dateTime\n    };\n    const allFormats = {\n        date: {\n            ...mfDateDefaults,\n            ...dateTimeFormats\n        },\n        time: {\n            ...mfTimeDefaults,\n            ...dateTimeFormats\n        },\n        number: {\n            ...globalFormats?.number,\n            ...inlineFormats?.number\n        }\n    };\n    if (timeZone) {\n        // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n        // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n        [\n            \"date\",\n            \"time\"\n        ].forEach((property)=>{\n            const formats = allFormats[property];\n            for (const [key, value] of Object.entries(formats)){\n                formats[key] = {\n                    timeZone,\n                    ...value\n                };\n            }\n        });\n    }\n    return allFormats;\n}\nfunction joinPath(...parts) {\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction createCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {}\n    };\n}\nfunction createMemoCache(store) {\n    return {\n        create () {\n            return {\n                get (key) {\n                    return store[key];\n                },\n                set (key, value) {\n                    store[key] = value;\n                }\n            };\n        }\n    };\n}\nfunction memoFn(fn, cache) {\n    return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n        cache: createMemoCache(cache),\n        strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n    });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n    return memoFn((...args)=>new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n    const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n    const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n    const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n    const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n    const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n    const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n    return {\n        getDateTimeFormat,\n        getNumberFormat,\n        getPluralRules,\n        getRelativeTimeFormat,\n        getListFormat,\n        getDisplayNames\n    };\n}\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n    const getMessageFormat = memoFn((...args)=>new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], {\n            formatters: intlFormatters,\n            ...args[3]\n        }), cache.message);\n    return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(`No messages available at \\`${namespace}\\`.`);\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (part == null || next == null) {\n            throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    try {\n        if (!messages) {\n            throw new Error(`No messages were configured.`);\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!retrievedMessages) {\n            throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    // To improve runtime performance, only compile message if:\n    return(// 1. Values are provided\n    values || // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) || // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n     : candidate // Don't compile\n    );\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl({ cache, formats: globalFormats, formatters, getMessageFallback = defaultGetMessageFallback, locale, messagesOrError, namespace, onError, timeZone }) {\n    const hasMessagesError = messagesOrError instanceof IntlError;\n    function getFallbackFromErrorAndNotify(key, code, message, fallback) {\n        const error = new IntlError(code, message);\n        onError(error);\n        return fallback ?? getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats, _fallback) {\n        const fallback = _fallback;\n        let message;\n        if (hasMessagesError) {\n            if (fallback) {\n                message = fallback;\n            } else {\n                onError(messagesOrError);\n                return getMessageFallback({\n                    error: messagesOrError,\n                    key,\n                    namespace\n                });\n            }\n        } else {\n            const messages = messagesOrError;\n            try {\n                message = resolvePath(locale, messages, key, namespace);\n            } catch (error) {\n                if (fallback) {\n                    message = fallback;\n                } else {\n                    return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message, fallback);\n                }\n            }\n        }\n        if (typeof message === \"object\") {\n            let code, errorMessage;\n            if (Array.isArray(message)) {\n                code = IntlErrorCode.INVALID_MESSAGE;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/translations#arrays-of-messages`;\n                }\n            } else {\n                code = IntlErrorCode.INSUFFICIENT_PATH;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/translations#structuring-messages`;\n                }\n            }\n            return getFallbackFromErrorAndNotify(key, code, errorMessage);\n        }\n        let messageFormat;\n        // Hot path that avoids creating an `IntlMessageFormat` instance\n        const plainMessage = getPlainMessage(message, values);\n        if (plainMessage) return plainMessage;\n        // Lazy init the message formatter for better tree\n        // shaking in case message formatting is not used.\n        if (!formatters.getMessageFormat) {\n            formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n        }\n        try {\n            messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n                formatters: {\n                    ...formatters,\n                    getDateTimeFormat (locales, options) {\n                        // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                        return formatters.getDateTimeFormat(locales, {\n                            timeZone,\n                            ...options\n                        });\n                    }\n                }\n            });\n        } catch (error) {\n            const thrownError = error;\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? ` (${thrownError.originalMessage})` : \"\"), fallback);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            values ? prepareTranslationValues(values) : values);\n            if (formattedMessage == null) {\n                throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"}`);\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message, fallback);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Custom formats for numbers, dates and times. */ formats, _fallback) {\n        const result = translateBaseFn(key, values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats, _fallback)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (hasMessagesError) {\n            onError(messagesOrError);\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    translateFn.has = (key)=>{\n        if (hasMessagesError) {\n            return false;\n        }\n        try {\n            resolvePath(locale, messagesOrError, key, namespace);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n    const { _cache: cache = createCache(), _formatters: formatters = createIntlFormatters(cache), formats, locale, onError = defaultOnError, timeZone: globalTimeZone } = props;\n    function applyTimeZone(options) {\n        if (!options?.timeZone) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats?.[formatName];\n            if (!options) {\n                const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        if (overrides) {\n            options = {\n                ...options,\n                ...overrides\n            };\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n        } catch  {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(start, end, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.number, (options)=>formatters.getNumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        // Only read when necessary to avoid triggering a `dynamicIO` error\n        // unnecessarily (`now` is only needed for `format.relativeTime`)\n        if (props.now) {\n            return props.now;\n        } else {\n            onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n            return new Date();\n        }\n    }\n    function relativeTime(date, nowOrOptions) {\n        try {\n            let nowDate, unit;\n            const opts = {};\n            if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n                nowDate = new Date(nowOrOptions);\n            } else if (nowOrOptions) {\n                if (nowOrOptions.now != null) {\n                    nowDate = new Date(nowOrOptions.now);\n                } else {\n                    nowDate = getGlobalNow();\n                }\n                unit = nowOrOptions.unit;\n                opts.style = nowOrOptions.style;\n                // @ts-expect-error -- Types are slightly outdated\n                opts.numberingSystem = nowOrOptions.numberingSystem;\n            }\n            if (!nowDate) {\n                nowDate = getGlobalNow();\n            }\n            const dateDate = new Date(date);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            if (!unit) {\n                unit = resolveRelativeTimeUnit(seconds);\n            }\n            // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n            // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n            // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n            // not desired, as the given dates might cross a threshold were the\n            // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n            // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n            // case. By using `always` we can ensure correct output. The only exception\n            // is the formatting of times <1 second as \"now\".\n            opts.numeric = unit === \"second\" ? \"auto\" : \"always\";\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions, overrides) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, overrides, formats?.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach(([key, messageOrMessages])=>{\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += ` (at ${parentPath})`;\n            invalidKeyLabels.push(keyLabel);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? \"key\" : \"keys\"}: ${invalidKeyLabels.join(\", \")}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig({ formats, getMessageFallback, messages, onError, ...rest }) {\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        formats: formats || undefined,\n        messages: messages || undefined,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1DSURWTVMyRS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxrQkFBa0JDO0lBQ3RCQyxZQUFZQyxJQUFJLEVBQUVDLGVBQWUsQ0FBRTtRQUNqQyxJQUFJQyxVQUFVRjtRQUNkLElBQUlDLGlCQUFpQjtZQUNuQkMsV0FBVyxPQUFPRDtRQUNwQjtRQUNBLEtBQUssQ0FBQ0M7UUFDTixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJQyxpQkFBaUI7WUFDbkIsSUFBSSxDQUFDQSxlQUFlLEdBQUdBO1FBQ3pCO0lBQ0Y7QUFDRjtBQUVBLElBQUlFLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFvQixHQUFHO0lBQ3JDQSxhQUFhLENBQUMsa0JBQWtCLEdBQUc7SUFDbkNBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxtQkFBbUIsR0FBRztJQUNwQyxPQUFPQTtBQUNULEVBQUVBLGlCQUFpQixDQUFDO0FBRXBCOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGtDQUFrQ0MsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLFFBQVE7SUFDL0UsTUFBTUMsaUJBQWlCaEIsaUVBQWlCQSxDQUFDaUIsT0FBTyxDQUFDQyxJQUFJO0lBQ3JELE1BQU1DLGlCQUFpQm5CLGlFQUFpQkEsQ0FBQ2lCLE9BQU8sQ0FBQ0csSUFBSTtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEIsR0FBR1IsZUFBZVMsUUFBUTtRQUMxQixHQUFHUixlQUFlUSxRQUFRO0lBQzVCO0lBQ0EsTUFBTUMsYUFBYTtRQUNqQkws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Q3RCO0FBQ0Y7QUFFK08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za2F0ZS1zaGFycGVuZXItZmluZGVyLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L2luaXRpYWxpemVDb25maWctQ0lEVk1TMkUuanM/YTczYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRsTWVzc2FnZUZvcm1hdCB9IGZyb20gJ2ludGwtbWVzc2FnZWZvcm1hdCc7XG5pbXBvcnQgeyBpc1ZhbGlkRWxlbWVudCwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVtb2l6ZSwgc3RyYXRlZ2llcyB9IGZyb20gJ0Bmb3JtYXRqcy9mYXN0LW1lbW9pemUnO1xuXG5jbGFzcyBJbnRsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgIGxldCBtZXNzYWdlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICB9XG59XG5cbnZhciBJbnRsRXJyb3JDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChJbnRsRXJyb3JDb2RlKSB7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX01FU1NBR0VcIl0gPSBcIk1JU1NJTkdfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19GT1JNQVRcIl0gPSBcIk1JU1NJTkdfRk9STUFUXCI7XG4gIEludGxFcnJvckNvZGVbXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiXSA9IFwiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9QQVRIXCJdID0gXCJJTlNVRkZJQ0lFTlRfUEFUSFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9NRVNTQUdFXCJdID0gXCJJTlZBTElEX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfS0VZXCJdID0gXCJJTlZBTElEX0tFWVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRk9STUFUVElOR19FUlJPUlwiXSA9IFwiRk9STUFUVElOR19FUlJPUlwiO1xuICByZXR1cm4gSW50bEVycm9yQ29kZTtcbn0oSW50bEVycm9yQ29kZSB8fCB7fSk7XG5cbi8qKlxuICogYGludGwtbWVzc2FnZWZvcm1hdGAgdXNlcyBzZXBhcmF0ZSBrZXlzIGZvciBgZGF0ZWAgYW5kIGB0aW1lYCwgYnV0IHRoZXJlJ3NcbiAqIG9ubHkgb25lIG5hdGl2ZSBBUEk6IGBJbnRsLkRhdGVUaW1lRm9ybWF0YC4gQWRkaXRpb25hbGx5IHlvdSBtaWdodCB3YW50IHRvXG4gKiBpbmNsdWRlIGJvdGggYSB0aW1lIGFuZCBhIGRhdGUgaW4gYSB2YWx1ZSwgdGhlcmVmb3JlIHRoZSBzZXBhcmF0aW9uIGRvZXNuJ3RcbiAqIHNlZW0gc28gdXNlZnVsLiBXZSBvZmZlciBhIHNpbmdsZSBgZGF0ZVRpbWVgIG5hbWVzcGFjZSBpbnN0ZWFkLCBidXQgd2UgaGF2ZVxuICogdG8gY29udmVydCB0aGUgZm9ybWF0IGJlZm9yZSBgaW50bC1tZXNzYWdlZm9ybWF0YCBjYW4gYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGdsb2JhbEZvcm1hdHMsIGlubGluZUZvcm1hdHMsIHRpbWVab25lKSB7XG4gIGNvbnN0IG1mRGF0ZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXQuZm9ybWF0cy5kYXRlO1xuICBjb25zdCBtZlRpbWVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0LmZvcm1hdHMudGltZTtcbiAgY29uc3QgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICAgIC4uLmdsb2JhbEZvcm1hdHM/LmRhdGVUaW1lLFxuICAgIC4uLmlubGluZUZvcm1hdHM/LmRhdGVUaW1lXG4gIH07XG4gIGNvbnN0IGFsbEZvcm1hdHMgPSB7XG4gICAgZGF0ZToge1xuICAgICAgLi4ubWZEYXRlRGVmYXVsdHMsXG4gICAgICAuLi5kYXRlVGltZUZvcm1hdHNcbiAgICB9LFxuICAgIHRpbWU6IHtcbiAgICAgIC4uLm1mVGltZURlZmF1bHRzLFxuICAgICAgLi4uZGF0ZVRpbWVGb3JtYXRzXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIC4uLmdsb2JhbEZvcm1hdHM/Lm51bWJlcixcbiAgICAgIC4uLmlubGluZUZvcm1hdHM/Lm51bWJlclxuICAgIH1cbiAgICAvLyAobGlzdCBpcyBub3Qgc3VwcG9ydGVkIGluIElDVSBtZXNzYWdlcylcbiAgfTtcbiAgaWYgKHRpbWVab25lKSB7XG4gICAgLy8gVGhlIG9ubHkgd2F5IHRvIHNldCBhIHRpbWUgem9uZSB3aXRoIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGlzIHRvIG1lcmdlIGl0IGludG8gdGhlIGZvcm1hdHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvYmxvYi84MjU2YzUyNzE1MDVjZjI2MDZlNDhlM2M5N2VjZGQxNmVkZTRmMWI1L3BhY2thZ2VzL2ludGwvc3JjL21lc3NhZ2UudHMjTDE1XG4gICAgWydkYXRlJywgJ3RpbWUnXS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdHMgPSBhbGxGb3JtYXRzW3Byb3BlcnR5XTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcm1hdHMpKSB7XG4gICAgICAgIGZvcm1hdHNba2V5XSA9IHtcbiAgICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgICAuLi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhbGxGb3JtYXRzO1xufVxuXG5mdW5jdGlvbiBqb2luUGF0aCguLi5wYXJ0cykge1xuICByZXR1cm4gcGFydHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBDb250YWlucyBkZWZhdWx0cyB0aGF0IGFyZSB1c2VkIGZvciBhbGwgZW50cnkgcG9pbnRzIGludG8gdGhlIGNvcmUuXG4gKiBTZWUgYWxzbyBgSW5pdGlhbGl6ZWRJbnRsQ29uZmlndXJhdGlvbmAuXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayhwcm9wcykge1xuICByZXR1cm4gam9pblBhdGgocHJvcHMubmFtZXNwYWNlLCBwcm9wcy5rZXkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICByZXR1cm4ge1xuICAgIGRhdGVUaW1lOiB7fSxcbiAgICBudW1iZXI6IHt9LFxuICAgIG1lc3NhZ2U6IHt9LFxuICAgIHJlbGF0aXZlVGltZToge30sXG4gICAgcGx1cmFsUnVsZXM6IHt9LFxuICAgIGxpc3Q6IHt9LFxuICAgIGRpc3BsYXlOYW1lczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9DYWNoZShzdG9yZSkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWVtb0ZuKGZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb2l6ZShmbiwge1xuICAgIGNhY2hlOiBjcmVhdGVNZW1vQ2FjaGUoY2FjaGUpLFxuICAgIHN0cmF0ZWd5OiBzdHJhdGVnaWVzLnZhcmlhZGljXG4gIH0pO1xufVxuZnVuY3Rpb24gbWVtb0NvbnN0cnVjdG9yKENvbnN0cnVjdG9yRm4sIGNhY2hlKSB7XG4gIHJldHVybiBtZW1vRm4oKC4uLmFyZ3MpID0+IG5ldyBDb25zdHJ1Y3RvckZuKC4uLmFyZ3MpLCBjYWNoZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSkge1xuICBjb25zdCBnZXREYXRlVGltZUZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRhdGVUaW1lRm9ybWF0LCBjYWNoZS5kYXRlVGltZSk7XG4gIGNvbnN0IGdldE51bWJlckZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLk51bWJlckZvcm1hdCwgY2FjaGUubnVtYmVyKTtcbiAgY29uc3QgZ2V0UGx1cmFsUnVsZXMgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5QbHVyYWxSdWxlcywgY2FjaGUucGx1cmFsUnVsZXMpO1xuICBjb25zdCBnZXRSZWxhdGl2ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQsIGNhY2hlLnJlbGF0aXZlVGltZSk7XG4gIGNvbnN0IGdldExpc3RGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5MaXN0Rm9ybWF0LCBjYWNoZS5saXN0KTtcbiAgY29uc3QgZ2V0RGlzcGxheU5hbWVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuRGlzcGxheU5hbWVzLCBjYWNoZS5kaXNwbGF5TmFtZXMpO1xuICByZXR1cm4ge1xuICAgIGdldERhdGVUaW1lRm9ybWF0LFxuICAgIGdldE51bWJlckZvcm1hdCxcbiAgICBnZXRQbHVyYWxSdWxlcyxcbiAgICBnZXRSZWxhdGl2ZVRpbWVGb3JtYXQsXG4gICAgZ2V0TGlzdEZvcm1hdCxcbiAgICBnZXREaXNwbGF5TmFtZXNcbiAgfTtcbn1cblxuLy8gUGxhY2VkIGhlcmUgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZy4gU29tZWhvdyB3aGVuIHRoaXMgaXMgcGxhY2VkIGluXG4vLyBgZm9ybWF0dGVycy50c3hgLCB0aGVuIGl0IGNhbid0IGJlIHNoYWtlbiBvZmYgZnJvbSBgbmV4dC1pbnRsYC5cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGludGxGb3JtYXR0ZXJzKSB7XG4gIGNvbnN0IGdldE1lc3NhZ2VGb3JtYXQgPSBtZW1vRm4oKC4uLmFyZ3MpID0+IG5ldyBJbnRsTWVzc2FnZUZvcm1hdChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCB7XG4gICAgZm9ybWF0dGVyczogaW50bEZvcm1hdHRlcnMsXG4gICAgLi4uYXJnc1szXVxuICB9KSwgY2FjaGUubWVzc2FnZSk7XG4gIHJldHVybiBnZXRNZXNzYWdlRm9ybWF0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgZnVsbEtleSA9IGpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KTtcbiAgaWYgKCFtZXNzYWdlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWVzc2FnZXMgYXZhaWxhYmxlIGF0IFxcYCR7bmFtZXNwYWNlfVxcYC5gICk7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKHBhcnQgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc29sdmUgXFxgJHtmdWxsS2V5fVxcYCBpbiBtZXNzYWdlcyBmb3IgbG9jYWxlIFxcYCR7bG9jYWxlfVxcYC5gICk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBuZXh0O1xuICB9KTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSB7XG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9pc3N1ZXMvMTQ2N1xuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlcyA9IHt9O1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgbGV0IHRyYW5zZm9ybWVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gY2h1bmtzID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoY2h1bmtzKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChyZXN1bHQpID8gLyojX19QVVJFX18qL2Nsb25lRWxlbWVudChyZXN1bHQsIHtcbiAgICAgICAgICBrZXk6IGtleSArIGluZGV4KytcbiAgICAgICAgfSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHZhbHVlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1lZFZhbHVlc1trZXldID0gdHJhbnNmb3JtZWQ7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtZWRWYWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc09yRXJyb3IobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyB3ZXJlIGNvbmZpZ3VyZWQuYCApO1xuICAgIH1cbiAgICBjb25zdCByZXRyaWV2ZWRNZXNzYWdlcyA9IG5hbWVzcGFjZSA/IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkgOiBtZXNzYWdlcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKCFyZXRyaWV2ZWRNZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyBmb3IgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYCBmb3VuZC5gICk7XG4gICAgfVxuICAgIHJldHVybiByZXRyaWV2ZWRNZXNzYWdlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpbnRsRXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICByZXR1cm4gaW50bEVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQbGFpbk1lc3NhZ2UoY2FuZGlkYXRlLCB2YWx1ZXMpIHtcbiAgLy8gVG8gaW1wcm92ZSBydW50aW1lIHBlcmZvcm1hbmNlLCBvbmx5IGNvbXBpbGUgbWVzc2FnZSBpZjpcbiAgcmV0dXJuIChcbiAgICAvLyAxLiBWYWx1ZXMgYXJlIHByb3ZpZGVkXG4gICAgdmFsdWVzIHx8XG4gICAgLy8gMi4gVGhlcmUgYXJlIGVzY2FwZWQgYnJhY2VzIChlLmcuIFwiJ3tuYW1lJ31cIilcbiAgICAvJ1t7fV0vLnRlc3QoY2FuZGlkYXRlKSB8fFxuICAgIC8vIDMuIFRoZXJlIGFyZSBtaXNzaW5nIGFyZ3VtZW50cyBvciB0YWdzIChkZXYtb25seSBlcnJvciBoYW5kbGluZylcbiAgICAvPHx7Ly50ZXN0KGNhbmRpZGF0ZSkgPyB1bmRlZmluZWQgLy8gQ29tcGlsZVxuICAgIDogY2FuZGlkYXRlIC8vIERvbid0IGNvbXBpbGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKGNvbmZpZykge1xuICBjb25zdCBtZXNzYWdlc09yRXJyb3IgPSBnZXRNZXNzYWdlc09yRXJyb3IoY29uZmlnLmxvY2FsZSwgY29uZmlnLm1lc3NhZ2VzLCBjb25maWcubmFtZXNwYWNlKTtcbiAgcmV0dXJuIGNyZWF0ZUJhc2VUcmFuc2xhdG9ySW1wbCh7XG4gICAgLi4uY29uZmlnLFxuICAgIG1lc3NhZ2VzT3JFcnJvclxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9ySW1wbCh7XG4gIGNhY2hlLFxuICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICBmb3JtYXR0ZXJzLFxuICBnZXRNZXNzYWdlRmFsbGJhY2sgPSBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrLFxuICBsb2NhbGUsXG4gIG1lc3NhZ2VzT3JFcnJvcixcbiAgbmFtZXNwYWNlLFxuICBvbkVycm9yLFxuICB0aW1lWm9uZVxufSkge1xuICBjb25zdCBoYXNNZXNzYWdlc0Vycm9yID0gbWVzc2FnZXNPckVycm9yIGluc3RhbmNlb2YgSW50bEVycm9yO1xuICBmdW5jdGlvbiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIG1lc3NhZ2UsIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKGNvZGUsIG1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBmYWxsYmFjayA/PyBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgZXJyb3IsXG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVCYXNlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMsIF9mYWxsYmFjaykge1xuICAgIGNvbnN0IGZhbGxiYWNrID0gX2ZhbGxiYWNrO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgbWVzc2FnZSA9IGZhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25FcnJvcihtZXNzYWdlc09yRXJyb3IpO1xuICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVzc2FnZSA9IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgIG1lc3NhZ2UgPSBmYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSwgZmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBjb2RlLCBlcnJvck1lc3NhZ2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICBjb2RlID0gSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0U7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgTWVzc2FnZSBhdCBcXGAke2pvaW5QYXRoKG5hbWVzcGFjZSwga2V5KX1cXGAgcmVzb2x2ZWQgdG8gYW4gYXJyYXksIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL3RyYW5zbGF0aW9ucyNhcnJheXMtb2YtbWVzc2FnZXNgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlID0gSW50bEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfUEFUSDtcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBNZXNzYWdlIGF0IFxcYCR7am9pblBhdGgobmFtZXNwYWNlLCBrZXkpfVxcYCByZXNvbHZlZCB0byBhbiBvYmplY3QsIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gVXNlIGEgXFxgLlxcYCB0byByZXRyaWV2ZSBuZXN0ZWQgbWVzc2FnZXMuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS90cmFuc2xhdGlvbnMjc3RydWN0dXJpbmctbWVzc2FnZXNgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICBsZXQgbWVzc2FnZUZvcm1hdDtcblxuICAgIC8vIEhvdCBwYXRoIHRoYXQgYXZvaWRzIGNyZWF0aW5nIGFuIGBJbnRsTWVzc2FnZUZvcm1hdGAgaW5zdGFuY2VcbiAgICBjb25zdCBwbGFpbk1lc3NhZ2UgPSBnZXRQbGFpbk1lc3NhZ2UobWVzc2FnZSwgdmFsdWVzKTtcbiAgICBpZiAocGxhaW5NZXNzYWdlKSByZXR1cm4gcGxhaW5NZXNzYWdlO1xuXG4gICAgLy8gTGF6eSBpbml0IHRoZSBtZXNzYWdlIGZvcm1hdHRlciBmb3IgYmV0dGVyIHRyZWVcbiAgICAvLyBzaGFraW5nIGluIGNhc2UgbWVzc2FnZSBmb3JtYXR0aW5nIGlzIG5vdCB1c2VkLlxuICAgIGlmICghZm9ybWF0dGVycy5nZXRNZXNzYWdlRm9ybWF0KSB7XG4gICAgICBmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQgPSBjcmVhdGVNZXNzYWdlRm9ybWF0dGVyKGNhY2hlLCBmb3JtYXR0ZXJzKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2VGb3JtYXQgPSBmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQobWVzc2FnZSwgbG9jYWxlLCBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoZ2xvYmFsRm9ybWF0cywgZm9ybWF0cywgdGltZVpvbmUpLCB7XG4gICAgICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgICAuLi5mb3JtYXR0ZXJzLFxuICAgICAgICAgIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9pc3N1ZXMvNDI3OVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywge1xuICAgICAgICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgdGhyb3duRXJyb3IgPSBlcnJvcjtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCB0aHJvd25FcnJvci5tZXNzYWdlICsgKCdvcmlnaW5hbE1lc3NhZ2UnIGluIHRocm93bkVycm9yID8gYCAoJHt0aHJvd25FcnJvci5vcmlnaW5hbE1lc3NhZ2V9KWAgOiAnJykgLCBmYWxsYmFjayk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0gbWVzc2FnZUZvcm1hdC5mb3JtYXQoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGV4cGVjdHMgYSBkaWZmZXJlbnQgZm9ybWF0XG4gICAgICAvLyBmb3IgcmljaCB0ZXh0IGVsZW1lbnRzIHNpbmNlIGEgcmVjZW50IG1pbm9yIHVwZGF0ZS4gVGhpc1xuICAgICAgLy8gbmVlZHMgdG8gYmUgZXZhbHVhdGVkIGluIGRldGFpbCwgcG9zc2libHkgYWxzbyBpbiByZWdhcmRzXG4gICAgICAvLyB0byBiZSBhYmxlIHRvIGZvcm1hdCB0byBwYXJ0cy5cbiAgICAgIHZhbHVlcyA/IHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIDogdmFsdWVzKTtcbiAgICAgIGlmIChmb3JtYXR0ZWRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZm9ybWF0IFxcYCR7a2V5fVxcYCBpbiAke25hbWVzcGFjZSA/IGBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgYCA6ICdtZXNzYWdlcyd9YCApO1xuICAgICAgfVxuXG4gICAgICAvLyBMaW1pdCB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIHRvIHJldHVybiBzdHJpbmdzIG9yIFJlYWN0IGVsZW1lbnRzXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KGZvcm1hdHRlZE1lc3NhZ2UpIHx8XG4gICAgICAvLyBBcnJheXMgb2YgUmVhY3QgZWxlbWVudHNcbiAgICAgIEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkTWVzc2FnZSkgfHwgdHlwZW9mIGZvcm1hdHRlZE1lc3NhZ2UgPT09ICdzdHJpbmcnID8gZm9ybWF0dGVkTWVzc2FnZSA6IFN0cmluZyhmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlLCBmYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogQ3VzdG9tIGZvcm1hdHMgZm9yIG51bWJlcnMsIGRhdGVzIGFuZCB0aW1lcy4gKi9cbiAgZm9ybWF0cywgX2ZhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSwgdmFsdWVzLCBmb3JtYXRzLCBfZmFsbGJhY2spO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIGBUaGUgbWVzc2FnZSBcXGAke2tleX1cXGAgaW4gJHtuYW1lc3BhY2UgPyBgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYGAgOiAnbWVzc2FnZXMnfSBkaWRuJ3QgcmVzb2x2ZSB0byBhIHN0cmluZy4gSWYgeW91IHdhbnQgdG8gZm9ybWF0IHJpY2ggdGV4dCwgdXNlIFxcYHQucmljaFxcYCBpbnN0ZWFkLmAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmFuc2xhdGVGbi5yaWNoID0gdHJhbnNsYXRlQmFzZUZuO1xuXG4gIC8vIEF1Z21lbnQgYHRyYW5zbGF0ZUJhc2VGbmAgdG8gcmV0dXJuIHBsYWluIHN0cmluZ3NcbiAgdHJhbnNsYXRlRm4ubWFya3VwID0gKGtleSwgdmFsdWVzLCBmb3JtYXRzLCBfZmFsbGJhY2spID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYE1hcmt1cFRyYW5zbGF0aW9uVmFsdWVzYCBpcyBwcmFjdGljYWxseSBhIHN1YiB0eXBlXG4gICAgLy8gb2YgYFJpY2hUcmFuc2xhdGlvblZhbHVlc2AgYnV0IFR5cGVTY3JpcHQgaXNuJ3Qgc21hcnQgZW5vdWdoIGhlcmUuXG4gICAgdmFsdWVzLCBmb3JtYXRzLCBfZmFsbGJhY2spO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgXCJgdC5tYXJrdXBgIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgdGhhdCByZWNlaXZlIGFuZCByZXR1cm4gc3RyaW5ncy5cXG5cXG5FLmcuIHQubWFya3VwKCdtYXJrdXAnLCB7YjogKGNodW5rcykgPT4gYDxiPiR7Y2h1bmtzfTwvYj5gfSlcIik7XG4gICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB0cmFuc2xhdGVGbi5yYXcgPSBrZXkgPT4ge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICBvbkVycm9yKG1lc3NhZ2VzT3JFcnJvcik7XG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgdHJhbnNsYXRlRm4uaGFzID0ga2V5ID0+IHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlc09yRXJyb3IsIGtleSwgbmFtZXNwYWNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRyYW5zbGF0ZUZuO1xufVxuXG4vKipcbiAqIEZvciB0aGUgc3RyaWN0bHkgdHlwZWQgbWVzc2FnZXMgdG8gd29yayB3ZSBoYXZlIHRvIHdyYXAgdGhlIG5hbWVzcGFjZSBpbnRvXG4gKiBhIG1hbmRhdG9yeSBwcmVmaXguIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlUHJlZml4ID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlLnNsaWNlKChuYW1lc3BhY2VQcmVmaXggKyAnLicpLmxlbmd0aCk7XG59XG5cbmNvbnN0IFNFQ09ORCA9IDE7XG5jb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcbmNvbnN0IEhPVVIgPSBNSU5VVEUgKiA2MDtcbmNvbnN0IERBWSA9IEhPVVIgKiAyNDtcbmNvbnN0IFdFRUsgPSBEQVkgKiA3O1xuY29uc3QgTU9OVEggPSBEQVkgKiAoMzY1IC8gMTIpOyAvLyBBcHByb3hpbWF0aW9uXG5jb25zdCBRVUFSVEVSID0gTU9OVEggKiAzO1xuY29uc3QgWUVBUiA9IERBWSAqIDM2NTtcbmNvbnN0IFVOSVRfU0VDT05EUyA9IHtcbiAgc2Vjb25kOiBTRUNPTkQsXG4gIHNlY29uZHM6IFNFQ09ORCxcbiAgbWludXRlOiBNSU5VVEUsXG4gIG1pbnV0ZXM6IE1JTlVURSxcbiAgaG91cjogSE9VUixcbiAgaG91cnM6IEhPVVIsXG4gIGRheTogREFZLFxuICBkYXlzOiBEQVksXG4gIHdlZWs6IFdFRUssXG4gIHdlZWtzOiBXRUVLLFxuICBtb250aDogTU9OVEgsXG4gIG1vbnRoczogTU9OVEgsXG4gIHF1YXJ0ZXI6IFFVQVJURVIsXG4gIHF1YXJ0ZXJzOiBRVUFSVEVSLFxuICB5ZWFyOiBZRUFSLFxuICB5ZWFyczogWUVBUlxufTtcbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpIHtcbiAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhzZWNvbmRzKTtcbiAgaWYgKGFic1ZhbHVlIDwgTUlOVVRFKSB7XG4gICAgcmV0dXJuICdzZWNvbmQnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgSE9VUikge1xuICAgIHJldHVybiAnbWludXRlJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IERBWSkge1xuICAgIHJldHVybiAnaG91cic7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBXRUVLKSB7XG4gICAgcmV0dXJuICdkYXknO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgTU9OVEgpIHtcbiAgICByZXR1cm4gJ3dlZWsnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgWUVBUikge1xuICAgIHJldHVybiAnbW9udGgnO1xuICB9XG4gIHJldHVybiAneWVhcic7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KSB7XG4gIC8vIFdlIGhhdmUgdG8gcm91bmQgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIGFzIGBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdGBcbiAgLy8gd2lsbCBpbmNsdWRlIGZyYWN0aW9ucyBsaWtlICcyLjEgaG91cnMgYWdvJy5cbiAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyAvIFVOSVRfU0VDT05EU1t1bml0XSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIF9jYWNoZTogY2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgIF9mb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzID0gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpLFxuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvcixcbiAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgfSA9IHByb3BzO1xuICBmdW5jdGlvbiBhcHBseVRpbWVab25lKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnM/LnRpbWVab25lKSB7XG4gICAgICBpZiAoZ2xvYmFsVGltZVpvbmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGUgXFxgdGltZVpvbmVcXGAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZC4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQgdG8gYXZvaWQgbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBMZWFybiBtb3JlOiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZWAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXRPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzPy5bZm9ybWF0TmFtZV07XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuTUlTU0lOR19GT1JNQVQsIGBGb3JtYXQgXFxgJHtmb3JtYXROYW1lfVxcYCBpcyBub3QgYXZhaWxhYmxlLmAgKTtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZm9ybWF0T3JPcHRpb25zO1xuICAgIH1cbiAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5vdmVycmlkZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCB0eXBlRm9ybWF0cywgZm9ybWF0dGVyLCBnZXRGYWxsYmFjaykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWUodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKTtcbiAgICB9LCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfSwgKCkgPT4gW2RhdGVUaW1lKHN0YXJ0KSwgZGF0ZVRpbWUoZW5kKV0uam9pbign4oCJ4oCT4oCJJykpO1xuICB9XG4gIGZ1bmN0aW9uIG51bWJlcih2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/Lm51bWJlciwgb3B0aW9ucyA9PiBmb3JtYXR0ZXJzLmdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSksICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEdsb2JhbE5vdygpIHtcbiAgICAvLyBPbmx5IHJlYWQgd2hlbiBuZWNlc3NhcnkgdG8gYXZvaWQgdHJpZ2dlcmluZyBhIGBkeW5hbWljSU9gIGVycm9yXG4gICAgLy8gdW5uZWNlc3NhcmlseSAoYG5vd2AgaXMgb25seSBuZWVkZWQgZm9yIGBmb3JtYXQucmVsYXRpdmVUaW1lYClcbiAgICBpZiAocHJvcHMubm93KSB7XG4gICAgICByZXR1cm4gcHJvcHMubm93O1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgYFRoZSBcXGBub3dcXGAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCB0byBcXGByZWxhdGl2ZVRpbWVcXGAgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQsIHRoZXJlZm9yZSB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZCBhcyBhIGZhbGxiYWNrLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvZGF0ZXMtdGltZXMjcmVsYXRpdmUtdGltZXMtdXNlbm93YCApKTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUoZGF0ZSwgbm93T3JPcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBub3dEYXRlLCB1bml0O1xuICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgaWYgKG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIG5vd09yT3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm93RGF0ZSA9IG5ldyBEYXRlKG5vd09yT3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKG5vd09yT3B0aW9ucykge1xuICAgICAgICBpZiAobm93T3JPcHRpb25zLm5vdyAhPSBudWxsKSB7XG4gICAgICAgICAgbm93RGF0ZSA9IG5ldyBEYXRlKG5vd09yT3B0aW9ucy5ub3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vd0RhdGUgPSBnZXRHbG9iYWxOb3coKTtcbiAgICAgICAgfVxuICAgICAgICB1bml0ID0gbm93T3JPcHRpb25zLnVuaXQ7XG4gICAgICAgIG9wdHMuc3R5bGUgPSBub3dPck9wdGlvbnMuc3R5bGU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVHlwZXMgYXJlIHNsaWdodGx5IG91dGRhdGVkXG4gICAgICAgIG9wdHMubnVtYmVyaW5nU3lzdGVtID0gbm93T3JPcHRpb25zLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIH1cbiAgICAgIGlmICghbm93RGF0ZSkge1xuICAgICAgICBub3dEYXRlID0gZ2V0R2xvYmFsTm93KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRlRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgY29uc3Qgc2Vjb25kcyA9IChkYXRlRGF0ZS5nZXRUaW1lKCkgLSBub3dEYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgaWYgKCF1bml0KSB7XG4gICAgICAgIHVuaXQgPSByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gYG51bWVyaWM6ICdhdXRvJ2AgY2FuIHRoZW9yZXRpY2FsbHkgcHJvZHVjZSBvdXRwdXQgbGlrZSBcInllc3RlcmRheVwiLFxuICAgICAgLy8gYnV0IGl0IG9ubHkgd29ya3Mgd2l0aCBpbnRlZ2Vycy4gRS5nLiAtMSBkYXkgd2lsbCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsXG4gICAgICAvLyBidXQgLTEuMSBkYXlzIHdpbGwgcHJvZHVjZSBcIi0xLjEgZGF5c1wiLiBSb3VuZGluZyBiZWZvcmUgZm9ybWF0dGluZyBpc1xuICAgICAgLy8gbm90IGRlc2lyZWQsIGFzIHRoZSBnaXZlbiBkYXRlcyBtaWdodCBjcm9zcyBhIHRocmVzaG9sZCB3ZXJlIHRoZVxuICAgICAgLy8gb3V0cHV0IGlzbid0IGNvcnJlY3QgYW55bW9yZS4gRXhhbXBsZTogMjAyNC0wMS0wOFQyMzowMDowMC4wMDBaIGFuZFxuICAgICAgLy8gMjAyNC0wMS0wOFQwMTowMDowMC4wMDBaIHdvdWxkIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIiwgd2hpY2ggaXMgbm90IHRoZVxuICAgICAgLy8gY2FzZS4gQnkgdXNpbmcgYGFsd2F5c2Agd2UgY2FuIGVuc3VyZSBjb3JyZWN0IG91dHB1dC4gVGhlIG9ubHkgZXhjZXB0aW9uXG4gICAgICAvLyBpcyB0aGUgZm9ybWF0dGluZyBvZiB0aW1lcyA8MSBzZWNvbmQgYXMgXCJub3dcIi5cbiAgICAgIG9wdHMubnVtZXJpYyA9IHVuaXQgPT09ICdzZWNvbmQnID8gJ2F1dG8nIDogJ2Fsd2F5cyc7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0UmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0cykuZm9ybWF0KHZhbHVlLCB1bml0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIFN0cmluZyhkYXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdCh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSBbXTtcbiAgICBjb25zdCByaWNoVmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gYGZvcm1hdFRvUGFydHNgIG9ubHkgYWNjZXB0cyBzdHJpbmdzLCB0aGVyZWZvcmUgd2UgaGF2ZSB0byB0ZW1wb3JhcmlseVxuICAgIC8vIHJlcGxhY2UgUmVhY3QgZWxlbWVudHMgd2l0aCBhIHBsYWNlaG9sZGVyIElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmVcbiAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWUgYWZ0ZXJ3YXJkcy5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIHJpY2hWYWx1ZXMuc2V0KHNlcmlhbGl6ZWRJdGVtLCBpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gU3RyaW5nKGl0ZW0pO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplZFZhbHVlLnB1c2goc2VyaWFsaXplZEl0ZW0pO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5saXN0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYHJpY2hWYWx1ZXMuc2l6ZWAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlLCBidXQgVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0aGUgbWVhbmluZyBvZiB0aGlzIGNvcnJlY3RseVxuICAgIG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0dGVycy5nZXRMaXN0Rm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhzZXJpYWxpemVkVmFsdWUpLm1hcChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gcGFydC52YWx1ZSA6IHJpY2hWYWx1ZXMuZ2V0KHBhcnQudmFsdWUpIHx8IHBhcnQudmFsdWUpO1xuICAgICAgaWYgKHJpY2hWYWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZSxcbiAgICBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lLFxuICAgIGxpc3QsXG4gICAgZGF0ZVRpbWVSYW5nZVxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgcGFyZW50UGF0aCkge1xuICBPYmplY3QuZW50cmllcyhtZXNzYWdlcykuZm9yRWFjaCgoW2tleSwgbWVzc2FnZU9yTWVzc2FnZXNdKSA9PiB7XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBsZXQga2V5TGFiZWwgPSBrZXk7XG4gICAgICBpZiAocGFyZW50UGF0aCkga2V5TGFiZWwgKz0gYCAoYXQgJHtwYXJlbnRQYXRofSlgO1xuICAgICAgaW52YWxpZEtleUxhYmVscy5wdXNoKGtleUxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChtZXNzYWdlT3JNZXNzYWdlcyAhPSBudWxsICYmIHR5cGVvZiBtZXNzYWdlT3JNZXNzYWdlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VPck1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBqb2luUGF0aChwYXJlbnRQYXRoLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgb25FcnJvcikge1xuICBjb25zdCBpbnZhbGlkS2V5TGFiZWxzID0gW107XG4gIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzKTtcbiAgaWYgKGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLklOVkFMSURfS0VZLCBgTmFtZXNwYWNlIGtleXMgY2FuIG5vdCBjb250YWluIHRoZSBjaGFyYWN0ZXIgXCIuXCIgYXMgdGhpcyBpcyB1c2VkIHRvIGV4cHJlc3MgbmVzdGluZy4gUGxlYXNlIHJlbW92ZSBpdCBvciByZXBsYWNlIGl0IHdpdGggYW5vdGhlciBjaGFyYWN0ZXIuXG5cbkludmFsaWQgJHtpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA9PT0gMSA/ICdrZXknIDogJ2tleXMnfTogJHtpbnZhbGlkS2V5TGFiZWxzLmpvaW4oJywgJyl9XG5cbklmIHlvdSdyZSBtaWdyYXRpbmcgZnJvbSBhIGZsYXQgc3RydWN0dXJlLCB5b3UgY2FuIGNvbnZlcnQgeW91ciBtZXNzYWdlcyBhcyBmb2xsb3dzOlxuXG5pbXBvcnQge3NldH0gZnJvbSBcImxvZGFzaFwiO1xuXG5jb25zdCBpbnB1dCA9IHtcbiAgXCJvbmUub25lXCI6IFwiMS4xXCIsXG4gIFwib25lLnR3b1wiOiBcIjEuMlwiLFxuICBcInR3by5vbmUub25lXCI6IFwiMi4xLjFcIlxufTtcblxuY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMoaW5wdXQpLnJlZHVjZShcbiAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiBzZXQoYWNjLCBrZXksIHZhbHVlKSxcbiAge31cbik7XG5cbi8vIE91dHB1dDpcbi8vXG4vLyB7XG4vLyAgIFwib25lXCI6IHtcbi8vICAgICBcIm9uZVwiOiBcIjEuMVwiLFxuLy8gICAgIFwidHdvXCI6IFwiMS4yXCJcbi8vICAgfSxcbi8vICAgXCJ0d29cIjoge1xuLy8gICAgIFwib25lXCI6IHtcbi8vICAgICAgIFwib25lXCI6IFwiMi4xLjFcIlxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuYCApKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VzIHRoZSBpbmNvbWluZyBwcm9wcyB3aXRoIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQ29uZmlnKHtcbiAgZm9ybWF0cyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICBtZXNzYWdlcyxcbiAgb25FcnJvcixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBmaW5hbE9uRXJyb3IgPSBvbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xuICBjb25zdCBmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayA9IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuICB7XG4gICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBmaW5hbE9uRXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgZm9ybWF0czogZm9ybWF0cyB8fCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzIHx8IHVuZGVmaW5lZCxcbiAgICBvbkVycm9yOiBmaW5hbE9uRXJyb3IsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrOiBmaW5hbEdldE1lc3NhZ2VGYWxsYmFja1xuICB9O1xufVxuXG5leHBvcnQgeyBJbnRsRXJyb3IgYXMgSSwgSW50bEVycm9yQ29kZSBhcyBhLCBjcmVhdGVJbnRsRm9ybWF0dGVycyBhcyBiLCBjcmVhdGVGb3JtYXR0ZXIgYXMgYywgY3JlYXRlQ2FjaGUgYXMgZCwgY3JlYXRlQmFzZVRyYW5zbGF0b3IgYXMgZSwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayBhcyBmLCBkZWZhdWx0T25FcnJvciBhcyBnLCBpbml0aWFsaXplQ29uZmlnIGFzIGksIHJlc29sdmVOYW1lc3BhY2UgYXMgciB9O1xuIl0sIm5hbWVzIjpbIkludGxNZXNzYWdlRm9ybWF0IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJtZW1vaXplIiwic3RyYXRlZ2llcyIsIkludGxFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwib3JpZ2luYWxNZXNzYWdlIiwibWVzc2FnZSIsIkludGxFcnJvckNvZGUiLCJjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQiLCJnbG9iYWxGb3JtYXRzIiwiaW5saW5lRm9ybWF0cyIsInRpbWVab25lIiwibWZEYXRlRGVmYXVsdHMiLCJmb3JtYXRzIiwiZGF0ZSIsIm1mVGltZURlZmF1bHRzIiwidGltZSIsImRhdGVUaW1lRm9ybWF0cyIsImRhdGVUaW1lIiwiYWxsRm9ybWF0cyIsIm51bWJlciIsImZvckVhY2giLCJwcm9wZXJ0eSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImpvaW5QYXRoIiwicGFydHMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJwcm9wcyIsIm5hbWVzcGFjZSIsImRlZmF1bHRPbkVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwiY3JlYXRlQ2FjaGUiLCJyZWxhdGl2ZVRpbWUiLCJwbHVyYWxSdWxlcyIsImxpc3QiLCJkaXNwbGF5TmFtZXMiLCJjcmVhdGVNZW1vQ2FjaGUiLCJzdG9yZSIsImNyZWF0ZSIsImdldCIsInNldCIsIm1lbW9GbiIsImZuIiwiY2FjaGUiLCJzdHJhdGVneSIsInZhcmlhZGljIiwibWVtb0NvbnN0cnVjdG9yIiwiQ29uc3RydWN0b3JGbiIsImFyZ3MiLCJjcmVhdGVJbnRsRm9ybWF0dGVycyIsImdldERhdGVUaW1lRm9ybWF0IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiZ2V0TnVtYmVyRm9ybWF0IiwiTnVtYmVyRm9ybWF0IiwiZ2V0UGx1cmFsUnVsZXMiLCJQbHVyYWxSdWxlcyIsImdldFJlbGF0aXZlVGltZUZvcm1hdCIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImdldExpc3RGb3JtYXQiLCJMaXN0Rm9ybWF0IiwiZ2V0RGlzcGxheU5hbWVzIiwiRGlzcGxheU5hbWVzIiwiY3JlYXRlTWVzc2FnZUZvcm1hdHRlciIsImludGxGb3JtYXR0ZXJzIiwiZ2V0TWVzc2FnZUZvcm1hdCIsImZvcm1hdHRlcnMiLCJyZXNvbHZlUGF0aCIsImxvY2FsZSIsIm1lc3NhZ2VzIiwiZnVsbEtleSIsInNwbGl0IiwicGFydCIsIm5leHQiLCJwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMiLCJ2YWx1ZXMiLCJ0cmFuc2Zvcm1lZFZhbHVlcyIsImtleXMiLCJpbmRleCIsInRyYW5zZm9ybWVkIiwiY2h1bmtzIiwicmVzdWx0IiwiZ2V0TWVzc2FnZXNPckVycm9yIiwicmV0cmlldmVkTWVzc2FnZXMiLCJpbnRsRXJyb3IiLCJNSVNTSU5HX01FU1NBR0UiLCJnZXRQbGFpbk1lc3NhZ2UiLCJjYW5kaWRhdGUiLCJ0ZXN0IiwidW5kZWZpbmVkIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjb25maWciLCJtZXNzYWdlc09yRXJyb3IiLCJjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJvbkVycm9yIiwiaGFzTWVzc2FnZXNFcnJvciIsImdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5IiwiZmFsbGJhY2siLCJ0cmFuc2xhdGVCYXNlRm4iLCJfZmFsbGJhY2siLCJlcnJvck1lc3NhZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJJTlZBTElEX01FU1NBR0UiLCJJTlNVRkZJQ0lFTlRfUEFUSCIsIm1lc3NhZ2VGb3JtYXQiLCJwbGFpbk1lc3NhZ2UiLCJsb2NhbGVzIiwib3B0aW9ucyIsInRocm93bkVycm9yIiwiZm9ybWF0dGVkTWVzc2FnZSIsImZvcm1hdCIsIlN0cmluZyIsIkZPUk1BVFRJTkdfRVJST1IiLCJ0cmFuc2xhdGVGbiIsInJpY2giLCJtYXJrdXAiLCJyYXciLCJoYXMiLCJyZXNvbHZlTmFtZXNwYWNlIiwibmFtZXNwYWNlUHJlZml4Iiwic2xpY2UiLCJsZW5ndGgiLCJTRUNPTkQiLCJNSU5VVEUiLCJIT1VSIiwiREFZIiwiV0VFSyIsIk1PTlRIIiwiUVVBUlRFUiIsIllFQVIiLCJVTklUX1NFQ09ORFMiLCJzZWNvbmQiLCJzZWNvbmRzIiwibWludXRlIiwibWludXRlcyIsImhvdXIiLCJob3VycyIsImRheSIsImRheXMiLCJ3ZWVrIiwid2Vla3MiLCJtb250aCIsIm1vbnRocyIsInF1YXJ0ZXIiLCJxdWFydGVycyIsInllYXIiLCJ5ZWFycyIsInJlc29sdmVSZWxhdGl2ZVRpbWVVbml0IiwiYWJzVmFsdWUiLCJNYXRoIiwiYWJzIiwiY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUiLCJ1bml0Iiwicm91bmQiLCJjcmVhdGVGb3JtYXR0ZXIiLCJfY2FjaGUiLCJfZm9ybWF0dGVycyIsImdsb2JhbFRpbWVab25lIiwiYXBwbHlUaW1lWm9uZSIsIkVOVklST05NRU5UX0ZBTExCQUNLIiwicmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyIsInR5cGVGb3JtYXRzIiwiZm9ybWF0T3JPcHRpb25zIiwib3ZlcnJpZGVzIiwiZm9ybWF0TmFtZSIsIk1JU1NJTkdfRk9STUFUIiwiZ2V0Rm9ybWF0dGVkVmFsdWUiLCJmb3JtYXR0ZXIiLCJnZXRGYWxsYmFjayIsImRhdGVUaW1lUmFuZ2UiLCJzdGFydCIsImVuZCIsImZvcm1hdFJhbmdlIiwiZ2V0R2xvYmFsTm93Iiwibm93IiwiRGF0ZSIsIm5vd09yT3B0aW9ucyIsIm5vd0RhdGUiLCJvcHRzIiwic3R5bGUiLCJudW1iZXJpbmdTeXN0ZW0iLCJkYXRlRGF0ZSIsImdldFRpbWUiLCJudW1lcmljIiwic2VyaWFsaXplZFZhbHVlIiwicmljaFZhbHVlcyIsIk1hcCIsIml0ZW0iLCJzZXJpYWxpemVkSXRlbSIsInB1c2giLCJmb3JtYXRUb1BhcnRzIiwibWFwIiwidHlwZSIsInNpemUiLCJ2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudCIsImludmFsaWRLZXlMYWJlbHMiLCJwYXJlbnRQYXRoIiwibWVzc2FnZU9yTWVzc2FnZXMiLCJpbmNsdWRlcyIsImtleUxhYmVsIiwidmFsaWRhdGVNZXNzYWdlcyIsIklOVkFMSURfS0VZIiwiaW5pdGlhbGl6ZUNvbmZpZyIsInJlc3QiLCJmaW5hbE9uRXJyb3IiLCJmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayIsIkkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaSIsInIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/react.js":
/*!*************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/react.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntlProvider: () => (/* binding */ IntlProvider),\n/* harmony export */   _useExtracted: () => (/* binding */ useExtracted),\n/* harmony export */   useFormatter: () => (/* binding */ useFormatter),\n/* harmony export */   useLocale: () => (/* binding */ useLocale),\n/* harmony export */   useMessages: () => (/* binding */ useMessages),\n/* harmony export */   useNow: () => (/* binding */ useNow),\n/* harmony export */   useTimeZone: () => (/* binding */ useTimeZone),\n/* harmony export */   useTranslations: () => (/* binding */ useTranslations)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initializeConfig-CIDVMS2E.js */ \"(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n\n\n\nconst IntlContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nfunction IntlProvider({ children, formats, getMessageFallback, locale, messages, now, onError, timeZone }) {\n    const prevContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n    // The formatter cache is released when the locale changes. For\n    // long-running apps with a persistent `IntlProvider` at the root,\n    // this can reduce the memory footprint (e.g. in React Native).\n    const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return prevContext?.cache || (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.d)();\n    }, [\n        locale,\n        prevContext?.cache\n    ]);\n    const formatters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>prevContext?.formatters || (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.b)(cache), [\n        cache,\n        prevContext?.formatters\n    ]);\n    // Memoizing this value helps to avoid triggering a re-render of all\n    // context consumers in case the configuration didn't change. However,\n    // if some of the non-primitive values change, a re-render will still\n    // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n    // itself, because the `children` typically change on every render.\n    // There's some burden on the consumer side if it's important to reduce\n    // re-renders, put that's how React works.\n    // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.i)({\n                locale,\n                // (required by provider)\n                formats: formats === undefined ? prevContext?.formats : formats,\n                getMessageFallback: getMessageFallback || prevContext?.getMessageFallback,\n                messages: messages === undefined ? prevContext?.messages : messages,\n                now: now || prevContext?.now,\n                onError: onError || prevContext?.onError,\n                timeZone: timeZone || prevContext?.timeZone\n            }),\n            formatters,\n            cache\n        }), [\n        cache,\n        formats,\n        formatters,\n        getMessageFallback,\n        locale,\n        messages,\n        now,\n        onError,\n        prevContext,\n        timeZone\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IntlContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useIntlContext() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n    if (!context) {\n        throw new Error(\"No intl context found. Have you configured the provider? See https://next-intl.dev/docs/usage/configuration#server-client-components\");\n    }\n    return context;\n}\nlet hasWarnedForMissingTimezone = false;\nconst isServer = \"undefined\" === \"undefined\";\nfunction useTranslationsImpl(allMessagesPrefixed, namespacePrefixed, namespacePrefix) {\n    const { cache, formats: globalFormats, formatters, getMessageFallback, locale, onError, timeZone } = useIntlContext();\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the hook invocation.\n    const allMessages = allMessagesPrefixed[namespacePrefix];\n    const namespace = (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.r)(namespacePrefixed, namespacePrefix);\n    if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n        // eslint-disable-next-line react-compiler/react-compiler\n        hasWarnedForMissingTimezone = true;\n        onError(new _initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.I(_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.a.ENVIRONMENT_FALLBACK, `There is no \\`timeZone\\` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl.dev/docs/configuration#time-zone`));\n    }\n    const translate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.e)({\n            cache,\n            formatters,\n            getMessageFallback,\n            messages: allMessages,\n            namespace,\n            onError,\n            formats: globalFormats,\n            locale,\n            timeZone\n        }), [\n        cache,\n        formatters,\n        getMessageFallback,\n        allMessages,\n        namespace,\n        onError,\n        globalFormats,\n        locale,\n        timeZone\n    ]);\n    return translate;\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function useTranslations(namespace) {\n    const context = useIntlContext();\n    const messages = context.messages;\n    // We have to wrap the actual hook so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    // @ts-expect-error Use the explicit annotation instead\n    return useTranslationsImpl({\n        \"!\": messages\n    }, // @ts-expect-error\n    namespace ? `!.${namespace}` : \"!\", \"!\");\n}\nfunction useLocale() {\n    return useIntlContext().locale;\n}\nfunction getNow() {\n    return new Date();\n}\n/**\n * @see https://next-intl.dev/docs/usage/dates-times#relative-times-usenow\n */ function useNow(options) {\n    const updateInterval = options?.updateInterval;\n    const { now: globalNow } = useIntlContext();\n    const [now, setNow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalNow || getNow());\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!updateInterval) return;\n        const intervalId = setInterval(()=>{\n            setNow(getNow());\n        }, updateInterval);\n        return ()=>{\n            clearInterval(intervalId);\n        };\n    }, [\n        globalNow,\n        updateInterval\n    ]);\n    return updateInterval == null && globalNow ? globalNow : now;\n}\nfunction useTimeZone() {\n    return useIntlContext().timeZone;\n}\nfunction useMessages() {\n    const context = useIntlContext();\n    if (!context.messages) {\n        throw new Error(\"No messages found. Have you configured them correctly? See https://next-intl.dev/docs/configuration#messages\");\n    }\n    return context.messages;\n}\nfunction useFormatter() {\n    const { formats, formatters, locale, now: globalNow, onError, timeZone } = useIntlContext();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.c)({\n            formats,\n            locale,\n            now: globalNow,\n            onError,\n            timeZone,\n            _formatters: formatters\n        }), [\n        formats,\n        formatters,\n        globalNow,\n        locale,\n        onError,\n        timeZone\n    ]);\n}\nfunction getArgs(messageOrParams, ...rest) {\n    let message, values, formats;\n    if (typeof messageOrParams === \"string\") {\n        message = messageOrParams;\n        values = rest[0];\n        formats = rest[1];\n    } else {\n        message = messageOrParams.message;\n        values = messageOrParams.values;\n        formats = messageOrParams.formats;\n    // `description` is is not used at runtime\n    }\n    // @ts-expect-error -- Secret fallback parameter\n    return [\n        undefined,\n        // Always use fallback if not compiled\n        values,\n        formats,\n        message\n    ];\n}\n// Note: This API is usually compiled into `useTranslations`,\n// but there is some fallback handling which allows this hook\n// to still work when not being compiled.\n//\n// This is relevant for:\n// - Isolated environments like tests, Storybook, etc.\n// - Fallbacks in case an extracted message is not yet available\nfunction useExtracted(namespace) {\n    const t = useTranslations(namespace);\n    function translateFn(...params) {\n        // @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        return t(...getArgs(...params));\n    }\n    translateFn.rich = (...params)=>// @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        t.rich(...getArgs(...params));\n    translateFn.markup = (...params)=>// @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        t.markup(...getArgs(...params));\n    translateFn.has = function translateHasFn(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    message) {\n        // Not really something better we can do here\n        return true;\n    };\n    return translateFn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Y7QUFDZ0o7QUFDeEw7QUFJeEMsTUFBTXNCLGNBQWMsV0FBVyxHQUFFdEIsb0RBQWFBLENBQUN1QjtBQUUvQyxTQUFTQyxhQUFhLEVBQ3BCQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEMsa0JBQWtCLEVBQ2xCQyxNQUFNLEVBQ05DLFFBQVEsRUFDUkMsR0FBRyxFQUNIQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVDtJQUNDLE1BQU1DLGNBQWNoQyxpREFBVUEsQ0FBQ3FCO0lBRS9CLCtEQUErRDtJQUMvRCxrRUFBa0U7SUFDbEUsK0RBQStEO0lBQy9ELE1BQU1ZLFFBQVFoQyw4Q0FBT0EsQ0FBQztRQUNwQixPQUFPK0IsYUFBYUMsU0FBUzVCLGdFQUFXQTtJQUMxQyxHQUFHO1FBQUNzQjtRQUFRSyxhQUFhQztLQUFNO0lBQy9CLE1BQU1DLGFBQWFqQyw4Q0FBT0EsQ0FBQyxJQUFNK0IsYUFBYUUsY0FBYzNCLGdFQUFvQkEsQ0FBQzBCLFFBQVE7UUFBQ0E7UUFBT0QsYUFBYUU7S0FBVztJQUV6SCxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLHFFQUFxRTtJQUNyRSwwRUFBMEU7SUFDMUUsbUVBQW1FO0lBQ25FLHVFQUF1RTtJQUN2RSwwQ0FBMEM7SUFDMUMsK0pBQStKO0lBQy9KLE1BQU1DLFFBQVFsQyw4Q0FBT0EsQ0FBQyxJQUFPO1lBQzNCLEdBQUdRLGdFQUFnQkEsQ0FBQztnQkFDbEJrQjtnQkFDQSx5QkFBeUI7Z0JBQ3pCRixTQUFTQSxZQUFZSCxZQUFZVSxhQUFhUCxVQUFVQTtnQkFDeERDLG9CQUFvQkEsc0JBQXNCTSxhQUFhTjtnQkFDdkRFLFVBQVVBLGFBQWFOLFlBQVlVLGFBQWFKLFdBQVdBO2dCQUMzREMsS0FBS0EsT0FBT0csYUFBYUg7Z0JBQ3pCQyxTQUFTQSxXQUFXRSxhQUFhRjtnQkFDakND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V0FBV1E7SUFDckJELFlBQVlHLE1BQU0sR0FBRyxDQUFDLEdBQUdGLFNBQ3pCLDRFQUE0RTtRQUM1RUYsRUFBRUksTUFBTSxJQUFJVixXQUFXUTtJQUN2QkQsWUFBWUksR0FBRyxHQUFHLFNBQVNDLGVBQzNCLDZEQUE2RDtJQUM3RFQsT0FBTztRQUNMLDZDQUE2QztRQUM3QyxPQUFPO0lBQ1Q7SUFDQSxPQUFPSTtBQUNUO0FBRW1JIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2thdGUtc2hhcnBlbmVyLWZpbmRlci8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2VzbS9kZXZlbG9wbWVudC9yZWFjdC5qcz9mNmQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBkIGFzIGNyZWF0ZUNhY2hlLCBiIGFzIGNyZWF0ZUludGxGb3JtYXR0ZXJzLCBpIGFzIGluaXRpYWxpemVDb25maWcsIHIgYXMgcmVzb2x2ZU5hbWVzcGFjZSwgSSBhcyBJbnRsRXJyb3IsIGEgYXMgSW50bEVycm9yQ29kZSwgZSBhcyBjcmVhdGVCYXNlVHJhbnNsYXRvciwgYyBhcyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2luaXRpYWxpemVDb25maWctQ0lEVk1TMkUuanMnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG5cblxuY29uc3QgSW50bENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiBJbnRsUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgZm9ybWF0cyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICBsb2NhbGUsXG4gIG1lc3NhZ2VzLFxuICBub3csXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IHByZXZDb250ZXh0ID0gdXNlQ29udGV4dChJbnRsQ29udGV4dCk7XG5cbiAgLy8gVGhlIGZvcm1hdHRlciBjYWNoZSBpcyByZWxlYXNlZCB3aGVuIHRoZSBsb2NhbGUgY2hhbmdlcy4gRm9yXG4gIC8vIGxvbmctcnVubmluZyBhcHBzIHdpdGggYSBwZXJzaXN0ZW50IGBJbnRsUHJvdmlkZXJgIGF0IHRoZSByb290LFxuICAvLyB0aGlzIGNhbiByZWR1Y2UgdGhlIG1lbW9yeSBmb290cHJpbnQgKGUuZy4gaW4gUmVhY3QgTmF0aXZlKS5cbiAgY29uc3QgY2FjaGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gcHJldkNvbnRleHQ/LmNhY2hlIHx8IGNyZWF0ZUNhY2hlKCk7XG4gIH0sIFtsb2NhbGUsIHByZXZDb250ZXh0Py5jYWNoZV0pO1xuICBjb25zdCBmb3JtYXR0ZXJzID0gdXNlTWVtbygoKSA9PiBwcmV2Q29udGV4dD8uZm9ybWF0dGVycyB8fCBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSksIFtjYWNoZSwgcHJldkNvbnRleHQ/LmZvcm1hdHRlcnNdKTtcblxuICAvLyBNZW1vaXppbmcgdGhpcyB2YWx1ZSBoZWxwcyB0byBhdm9pZCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyIG9mIGFsbFxuICAvLyBjb250ZXh0IGNvbnN1bWVycyBpbiBjYXNlIHRoZSBjb25maWd1cmF0aW9uIGRpZG4ndCBjaGFuZ2UuIEhvd2V2ZXIsXG4gIC8vIGlmIHNvbWUgb2YgdGhlIG5vbi1wcmltaXRpdmUgdmFsdWVzIGNoYW5nZSwgYSByZS1yZW5kZXIgd2lsbCBzdGlsbFxuICAvLyBiZSB0cmlnZ2VyZWQuIE5vdGUgdGhhdCB0aGVyZSdzIG5vIG5lZWQgdG8gcHV0IGBtZW1vYCBvbiBgSW50bFByb3ZpZGVyYFxuICAvLyBpdHNlbGYsIGJlY2F1c2UgdGhlIGBjaGlsZHJlbmAgdHlwaWNhbGx5IGNoYW5nZSBvbiBldmVyeSByZW5kZXIuXG4gIC8vIFRoZXJlJ3Mgc29tZSBidXJkZW4gb24gdGhlIGNvbnN1bWVyIHNpZGUgaWYgaXQncyBpbXBvcnRhbnQgdG8gcmVkdWNlXG4gIC8vIHJlLXJlbmRlcnMsIHB1dCB0aGF0J3MgaG93IFJlYWN0IHdvcmtzLlxuICAvLyBTZWU6IGh0dHBzOi8vYmxvZy5pc3F1YXJlZHNvZnR3YXJlLmNvbS8yMDIwLzA1L2Jsb2dnZWQtYW5zd2Vycy1hLW1vc3RseS1jb21wbGV0ZS1ndWlkZS10by1yZWFjdC1yZW5kZXJpbmctYmVoYXZpb3IvI2NvbnRleHQtdXBkYXRlcy1hbmQtcmVuZGVyLW9wdGltaXphdGlvbnNcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgLi4uaW5pdGlhbGl6ZUNvbmZpZyh7XG4gICAgICBsb2NhbGUsXG4gICAgICAvLyAocmVxdWlyZWQgYnkgcHJvdmlkZXIpXG4gICAgICBmb3JtYXRzOiBmb3JtYXRzID09PSB1bmRlZmluZWQgPyBwcmV2Q29udGV4dD8uZm9ybWF0cyA6IGZvcm1hdHMsXG4gICAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBwcmV2Q29udGV4dD8uZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzID09PSB1bmRlZmluZWQgPyBwcmV2Q29udGV4dD8ubWVzc2FnZXMgOiBtZXNzYWdlcyxcbiAgICAgIG5vdzogbm93IHx8IHByZXZDb250ZXh0Py5ub3csXG4gICAgICBvbkVycm9yOiBvbkVycm9yIHx8IHByZXZDb250ZXh0Py5vbkVycm9yLFxuICAgICAgdGltZVpvbmU6IHRpbWVab25lIHx8IHByZXZDb250ZXh0Py50aW1lWm9uZVxuICAgIH0pLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgY2FjaGVcbiAgfSksIFtjYWNoZSwgZm9ybWF0cywgZm9ybWF0dGVycywgZ2V0TWVzc2FnZUZhbGxiYWNrLCBsb2NhbGUsIG1lc3NhZ2VzLCBub3csIG9uRXJyb3IsIHByZXZDb250ZXh0LCB0aW1lWm9uZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChJbnRsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUludGxDb250ZXh0KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJbnRsQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gaW50bCBjb250ZXh0IGZvdW5kLiBIYXZlIHlvdSBjb25maWd1cmVkIHRoZSBwcm92aWRlcj8gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2NvbmZpZ3VyYXRpb24jc2VydmVyLWNsaWVudC1jb21wb25lbnRzJyApO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5sZXQgaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lID0gZmFsc2U7XG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zSW1wbChhbGxNZXNzYWdlc1ByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXhlZCwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIGNvbnN0IHtcbiAgICBjYWNoZSxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSB1c2VJbnRsQ29udGV4dCgpO1xuXG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBob29rIGludm9jYXRpb24uXG4gIGNvbnN0IGFsbE1lc3NhZ2VzID0gYWxsTWVzc2FnZXNQcmVmaXhlZFtuYW1lc3BhY2VQcmVmaXhdO1xuICBjb25zdCBuYW1lc3BhY2UgPSByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZVByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXgpO1xuICBpZiAoIXRpbWVab25lICYmICFoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgJiYgaXNTZXJ2ZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtY29tcGlsZXIvcmVhY3QtY29tcGlsZXJcbiAgICBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSB0cnVlO1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlcmUgaXMgbm8gXFxgdGltZVpvbmVcXGAgY29uZmlndXJlZCwgdGhpcyBjYW4gbGVhZCB0byBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0OiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZWAgKSk7XG4gIH1cbiAgY29uc3QgdHJhbnNsYXRlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgY2FjaGUsXG4gICAgZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXM6IGFsbE1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIHRpbWVab25lXG4gIH0pLCBbY2FjaGUsIGZvcm1hdHRlcnMsIGdldE1lc3NhZ2VGYWxsYmFjaywgYWxsTWVzc2FnZXMsIG5hbWVzcGFjZSwgb25FcnJvciwgZ2xvYmFsRm9ybWF0cywgbG9jYWxlLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gdHJhbnNsYXRlO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zKG5hbWVzcGFjZSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0Lm1lc3NhZ2VzO1xuXG4gIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgYWN0dWFsIGhvb2sgc28gdGhlIHR5cGUgaW5mZXJlbmNlIGZvciB0aGUgb3B0aW9uYWxcbiAgLy8gbmFtZXNwYWNlIHdvcmtzIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAgLy8gVGhlIHByZWZpeCAoXCIhXCIpIGlzIGFyYml0cmFyeS5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBVc2UgdGhlIGV4cGxpY2l0IGFubm90YXRpb24gaW5zdGVhZFxuICByZXR1cm4gdXNlVHJhbnNsYXRpb25zSW1wbCh7XG4gICAgJyEnOiBtZXNzYWdlc1xuICB9LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG5hbWVzcGFjZSA/IGAhLiR7bmFtZXNwYWNlfWAgOiAnIScsICchJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUxvY2FsZSgpIHtcbiAgcmV0dXJuIHVzZUludGxDb250ZXh0KCkubG9jYWxlO1xufVxuXG5mdW5jdGlvbiBnZXROb3coKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvZGF0ZXMtdGltZXMjcmVsYXRpdmUtdGltZXMtdXNlbm93XG4gKi9cbmZ1bmN0aW9uIHVzZU5vdyhvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZUludGVydmFsID0gb3B0aW9ucz8udXBkYXRlSW50ZXJ2YWw7XG4gIGNvbnN0IHtcbiAgICBub3c6IGdsb2JhbE5vd1xuICB9ID0gdXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgW25vdywgc2V0Tm93XSA9IHVzZVN0YXRlKGdsb2JhbE5vdyB8fCBnZXROb3coKSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1cGRhdGVJbnRlcnZhbCkgcmV0dXJuO1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXROb3coZ2V0Tm93KCkpO1xuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuICB9LCBbZ2xvYmFsTm93LCB1cGRhdGVJbnRlcnZhbF0pO1xuICByZXR1cm4gdXBkYXRlSW50ZXJ2YWwgPT0gbnVsbCAmJiBnbG9iYWxOb3cgPyBnbG9iYWxOb3cgOiBub3c7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVab25lKCkge1xuICByZXR1cm4gdXNlSW50bENvbnRleHQoKS50aW1lWm9uZTtcbn1cblxuZnVuY3Rpb24gdXNlTWVzc2FnZXMoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VJbnRsQ29udGV4dCgpO1xuICBpZiAoIWNvbnRleHQubWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1lc3NhZ2VzIGZvdW5kLiBIYXZlIHlvdSBjb25maWd1cmVkIHRoZW0gY29ycmVjdGx5PyBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiNtZXNzYWdlcycgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5tZXNzYWdlcztcbn1cblxuZnVuY3Rpb24gdXNlRm9ybWF0dGVyKCkge1xuICBjb25zdCB7XG4gICAgZm9ybWF0cyxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSB1c2VJbnRsQ29udGV4dCgpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmUsXG4gICAgX2Zvcm1hdHRlcnM6IGZvcm1hdHRlcnNcbiAgfSksIFtmb3JtYXRzLCBmb3JtYXR0ZXJzLCBnbG9iYWxOb3csIGxvY2FsZSwgb25FcnJvciwgdGltZVpvbmVdKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJncyhtZXNzYWdlT3JQYXJhbXMsIC4uLnJlc3QpIHtcbiAgbGV0IG1lc3NhZ2UsIHZhbHVlcywgZm9ybWF0cztcbiAgaWYgKHR5cGVvZiBtZXNzYWdlT3JQYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2VPclBhcmFtcztcbiAgICB2YWx1ZXMgPSByZXN0WzBdO1xuICAgIGZvcm1hdHMgPSByZXN0WzFdO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlT3JQYXJhbXMubWVzc2FnZTtcbiAgICB2YWx1ZXMgPSBtZXNzYWdlT3JQYXJhbXMudmFsdWVzO1xuICAgIGZvcm1hdHMgPSBtZXNzYWdlT3JQYXJhbXMuZm9ybWF0cztcbiAgICAvLyBgZGVzY3JpcHRpb25gIGlzIGlzIG5vdCB1c2VkIGF0IHJ1bnRpbWVcbiAgfVxuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFNlY3JldCBmYWxsYmFjayBwYXJhbWV0ZXJcbiAgcmV0dXJuIFt1bmRlZmluZWQsXG4gIC8vIEFsd2F5cyB1c2UgZmFsbGJhY2sgaWYgbm90IGNvbXBpbGVkXG4gIHZhbHVlcywgZm9ybWF0cywgbWVzc2FnZSBdO1xufVxuXG4vLyBOb3RlOiBUaGlzIEFQSSBpcyB1c3VhbGx5IGNvbXBpbGVkIGludG8gYHVzZVRyYW5zbGF0aW9uc2AsXG4vLyBidXQgdGhlcmUgaXMgc29tZSBmYWxsYmFjayBoYW5kbGluZyB3aGljaCBhbGxvd3MgdGhpcyBob29rXG4vLyB0byBzdGlsbCB3b3JrIHdoZW4gbm90IGJlaW5nIGNvbXBpbGVkLlxuLy9cbi8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yOlxuLy8gLSBJc29sYXRlZCBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cywgU3Rvcnlib29rLCBldGMuXG4vLyAtIEZhbGxiYWNrcyBpbiBjYXNlIGFuIGV4dHJhY3RlZCBtZXNzYWdlIGlzIG5vdCB5ZXQgYXZhaWxhYmxlXG5mdW5jdGlvbiB1c2VFeHRyYWN0ZWQobmFtZXNwYWNlKSB7XG4gIGNvbnN0IHQgPSB1c2VUcmFuc2xhdGlvbnMobmFtZXNwYWNlKTtcbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oLi4ucGFyYW1zKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBQYXNzaW5nIGB1bmRlZmluZWRgIGFzIGFuIElEIGlzIHNlY3JldGx5IGFsbG93ZWQgaGVyZVxuICAgIHJldHVybiB0KC4uLmdldEFyZ3MoLi4ucGFyYW1zKSk7XG4gIH1cbiAgdHJhbnNsYXRlRm4ucmljaCA9ICguLi5wYXJhbXMpID0+XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUGFzc2luZyBgdW5kZWZpbmVkYCBhcyBhbiBJRCBpcyBzZWNyZXRseSBhbGxvd2VkIGhlcmVcbiAgdC5yaWNoKC4uLmdldEFyZ3MoLi4ucGFyYW1zKSk7XG4gIHRyYW5zbGF0ZUZuLm1hcmt1cCA9ICguLi5wYXJhbXMpID0+XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gUGFzc2luZyBgdW5kZWZpbmVkYCBhcyBhbiBJRCBpcyBzZWNyZXRseSBhbGxvd2VkIGhlcmVcbiAgdC5tYXJrdXAoLi4uZ2V0QXJncyguLi5wYXJhbXMpKTtcbiAgdHJhbnNsYXRlRm4uaGFzID0gZnVuY3Rpb24gdHJhbnNsYXRlSGFzRm4oXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgbWVzc2FnZSkge1xuICAgIC8vIE5vdCByZWFsbHkgc29tZXRoaW5nIGJldHRlciB3ZSBjYW4gZG8gaGVyZVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICByZXR1cm4gdHJhbnNsYXRlRm47XG59XG5cbmV4cG9ydCB7IEludGxQcm92aWRlciwgdXNlRXh0cmFjdGVkIGFzIF91c2VFeHRyYWN0ZWQsIHVzZUZvcm1hdHRlciwgdXNlTG9jYWxlLCB1c2VNZXNzYWdlcywgdXNlTm93LCB1c2VUaW1lWm9uZSwgdXNlVHJhbnNsYXRpb25zIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VNZW1vIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJkIiwiY3JlYXRlQ2FjaGUiLCJiIiwiY3JlYXRlSW50bEZvcm1hdHRlcnMiLCJpIiwiaW5pdGlhbGl6ZUNvbmZpZyIsInIiLCJyZXNvbHZlTmFtZXNwYWNlIiwiSSIsIkludGxFcnJvciIsImEiLCJJbnRsRXJyb3JDb2RlIiwiZSIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwiYyIsImNyZWF0ZUZvcm1hdHRlciIsImpzeCIsIkludGxDb250ZXh0IiwidW5kZWZpbmVkIiwiSW50bFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJmb3JtYXRzIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwibG9jYWxlIiwibWVzc2FnZXMiLCJub3ciLCJvbkVycm9yIiwidGltZVpvbmUiLCJwcmV2Q29udGV4dCIsImNhY2hlIiwiZm9ybWF0dGVycyIsInZhbHVlIiwiUHJvdmlkZXIiLCJ1c2VJbnRsQ29udGV4dCIsImNvbnRleHQiLCJFcnJvciIsImhhc1dhcm5lZEZvck1pc3NpbmdUaW1lem9uZSIsImlzU2VydmVyIiwidXNlVHJhbnNsYXRpb25zSW1wbCIsImFsbE1lc3NhZ2VzUHJlZml4ZWQiLCJuYW1lc3BhY2VQcmVmaXhlZCIsIm5hbWVzcGFjZVByZWZpeCIsImdsb2JhbEZvcm1hdHMiLCJhbGxNZXNzYWdlcyIsIm5hbWVzcGFjZSIsIkVOVklST05NRU5UX0ZBTExCQUNLIiwidHJhbnNsYXRlIiwidXNlVHJhbnNsYXRpb25zIiwidXNlTG9jYWxlIiwiZ2V0Tm93IiwiRGF0ZSIsInVzZU5vdyIsIm9wdGlvbnMiLCJ1cGRhdGVJbnRlcnZhbCIsImdsb2JhbE5vdyIsInNldE5vdyIsImludGVydmFsSWQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ1c2VUaW1lWm9uZSIsInVzZU1lc3NhZ2VzIiwidXNlRm9ybWF0dGVyIiwiX2Zvcm1hdHRlcnMiLCJnZXRBcmdzIiwibWVzc2FnZU9yUGFyYW1zIiwicmVzdCIsIm1lc3NhZ2UiLCJ2YWx1ZXMiLCJ1c2VFeHRyYWN0ZWQiLCJ0IiwidHJhbnNsYXRlRm4iLCJwYXJhbXMiLCJyaWNoIiwibWFya3VwIiwiaGFzIiwidHJhbnNsYXRlSGFzRm4iLCJfdXNlRXh0cmFjdGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/react.js\n");

/***/ })

};
;